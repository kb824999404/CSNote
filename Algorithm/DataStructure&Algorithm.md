# 算法

## 1. 排序

* 插入排序：
  * 普通插入排序
  * 希尔排序
* 归并排序：
  * 归并排序求逆序数
* 快速排序：
  * 单路快排
  * 双路快排
  * 三路快排
  * 取第k大元素

### 1.1 堆

* shift up
* shift down
* 堆排序构造堆，从第一个非叶子节点开始shift down
* 原地堆排序
* 索引堆：对索引数组排序

---

## 2. 搜索

### 2.1 二分搜索树

* 插入
* 查找
* 遍历：
  * 先序
  * 中序
  * 后序
  * 层次
* 删除
  * 只有左孩子
  * 只有右孩子
  * 有左右孩子

### 2.2 并查集

* 查找
* 合并
  * 数量优化：元素少的指向元素多的
  * 层数优化：层数少的指向层数多的
* 路径压缩

### 2.3 图

* 深度优先遍历
  * 求联通分量
  * 寻路算法
    * from数组
    * 栈
* 广度优先遍历
  * 求最短路径：
    * 队列
    * distance数组

---

# 数据结构

## 2. 线性表

### 2.1 顺序表

* 插入：整体往后移
* 删除：整体往前移
* 修改

### 2.2 链表

#### 单链表

* 插入：
  * 头部
  * 中间
  * 尾部
* 删除
* 查找
* 修改

#### 双链表

* 插入：
  * 头部
  * 中间
  * 尾部
* 删除：
  * 开头
  * 末尾
  * 中间

#### 循环单向链表

* 插入：
  * 开头
  * 末尾
* 删除：
  * 开头
  * 末尾

#### 循环双向链表

* 插入：
  * 开头
  * 末尾
* 删除：
  * 开头
  * 末尾

---

### 2.3 栈

* 数组实现：
  * 推入
  * 弹出
* 链表实现：头指针指向栈顶
  * 推入
  * 弹出

### 2.4 队列

* 数组实现：
  * 插入
  * 删除
* 链表实现：
  * 插入：尾指针
  * 删除：头指针
* 循环队列：
  * 插入：
    * 队列已满
    * 尾部到头归零
    * 尾部未到头
  * 删除

---

## 3. 树

* 树：
  * 一般树
  * 森林
  * 二叉树
  * 二叉搜索树

### 3.1 二叉树

* 遍历：
  * 前序
  * 中序
  * 后序

### 3.2 二叉搜索树

* 创建
* 插入
* 删除：
  * 叶节点
  * 一个子节点
  * 两个子节点
    * 中序遍历的前导(左子树最大节点)替换
    * 中序遍历的后继(右子树的最小节点)替换

### 3.3 平衡搜索树(AVL树)

* 插入：
  * LL旋转：左子树的左子树
  * RR旋转：右子树的右子树
  * LR旋转：左子树的右子树
  * RL旋转：右子树的左子树 
* 删除：
  * 从右子树删除：
    * R0旋转：左子树为0
    * R1旋转：左子树为1
    * R-1旋转：左子树为-1
  * 从左子树删除

### 3.4 霍夫曼树

带权路径和最小

---

## 4. 图

* 表示方法：
  * 邻接矩阵
  * 邻接表
  * 十字链表：有向图
  * 多重邻接表：无向图
* 遍历：
  * 广度优先搜索
  * 深度优先搜索
* 最小生成树
  * Prim算法：选最近的点；最小堆，O(ElogV)
  * Kruskal算法：按权值升序选边，来自不同连通分量的加入；最小堆+并查集，O(ElogE)
* 最短路径：
  * Dijkstra算法：$O(V^2)$ 
  * Floyd-Warshall算法：$O(V^3)$ 
* 拓扑排序
* AOE网络：顶点表示事件，有向边表示活动
  * 关键路径：最大路径长度
  * $O(V+E)$

---

## 5. 排序

* 冒泡排序
* 选择排序
* 插入排序
  * 希尔排序
* 堆排序
* 归并排序
* 快速排序

---

## 补充

* 稀疏矩阵：
  * 存储：三元组
  * 转置：辅助数组`rowSize`和`rowStart`
* 算法课：
  * gcd：

    * 欧几里得 
    * 线性筛法

  * 复杂度：
    * $O(log\ n)<O(n^\alpha)<O(a^n)<O(n!)<O(n^n)$  
    * 非递归：确定基本步骤
    * 递归：确定递推式
      * 展开
      * 代入
    
  * 蛮力法：

    * 选择排序
    * 冒泡排序
    * 穷举搜索：
      * 排列组合问题：TSP问题
      * 子集问题：0-1背包问题
      * 最优问题：
        * 生成所有解
        * 选择满足约束条件的解
        * 评价解，保留最优解

  * 递归算法：

    * 阶乘
    * 斐波那契数列
    * 汉诺塔
    * 排列问题
    * 主定理：$T(n)=aT(n/b)+f(n),f(n)\in \Theta(n^k)$
      1. $a<b^k,T(n)\in \Theta(n^k)$
      2. $a=b^k,T(n)\in\Theta(n^klog\ n)$
      3. $a>b^k,T(n)\in(n^{\log_b a})$ 

  * 分治法：

    * 步骤：划分；解决子问题；合并解
    * $T(n)=aT(n/b)+f(n)$ 
    * 例子：
      * 大整数相乘
      * 方阵相乘
      * 二分搜索
      * 归并排序
      * 快速排序
      * 棋盘覆盖问题

  * 减治法：

    * 类型：减常量，减常数因子，减可变规模
    * 例子：
      * 减常量：
        * 插入排序
        * 拓扑排序：
          * DFS解法：入栈顺序
          * 去除零入度顶点法
      * 减常数因子：
        * 二分搜索
        * 假币问题
        * 俄国农夫乘法
      * 减可变规模：
        * 欧几里得算法

  * 变治法：

    * 类型：实例化简；改变表现；问题化简
    * 例子：
      * 实例化简：
        * 预排序：
          * 查找：预排序+二分法
          * 元素单一性
        * 高斯消去法
      * 改变表现：
        * 堆排序
        * 霍纳法则求多项式函数值
      * 问题化简：
        * 点在直线的哪一侧
        * 线性规划：背包问题
        * 转化为图

  * 搜索算法：

    * 类型：
      * 穷举搜索
      * 盲目搜索：
        * DFS或回溯法
        * BFS
        * 分支界限法
        * 剪枝
      * 启发式搜索：
        * A*
        * 迭代加深
    * 搜索问题：
      * 解向量：如$n$元式
      * 显约束：对解向量分量的取值限定
      * 隐约束：对解向量不同分量之间施加的约束
      * 解空间：满足显式约束的所有解向量
      * 常见解空间树：
        * 子集树：$\Omega(2^n)$
          * 0-1背包
        * 排列树：$\Omega(n!)$
          * TSP问题
          * n皇后问题
    * 回溯法：
      * 用DFS搜索解空间，遇到死结点则回溯
      * 剪枝函数：
        * 约束函数：不满足隐约束
        * 限界函数：得不到最优解
      * 特点：
        * 动态产生问题的解空间，只保存根结点到当前扩展结点的路径
        * 有剪枝时，搜索时让可取值少的分量优先可提高效率
    * 分支界限法：
      * 以BFS方式或优先队列方式搜索，用限界函数剪枝
      * 问题：
        * 0-1背包：
          * 物体按单位重量价值从大到小排序
          * 结点的上界和优先级为已装袋的物品价值加上剩下的最大单位重量价值的物品装满剩余容量的价值和
        * 装载问题：两艘船，尽可能装满第一艘再装第二艘
        * TSP问题：
          * 优先级用费用的下界定义，下界为顶点最小出边之和
    * 回溯法和分支界限法区别：
      * 求解目标：回溯法所有解；分支界限法一个解
      * 搜索方法
      * 结点扩展方式
      * 存储空间
    * 回溯法和穷举法区别：
      * 穷举法将一个解完成生成后，才判断是否满足条件，不满足则放弃该完整解，再重新生成
      * 回溯法将一个解逐步生成，当部分解不满足条件时，则回退一步，而非放弃整个解

  * 动态规划：

    * 多阶段决策问题：把多阶段过程转化为一系列单阶段问题，逐个求解
    * 动态规划：
      * 阶段：求解过程
      * 状态：无后效性(马尔可夫性)，该阶段以后过程的发展不受该阶段以前各阶段状态的影响
      * 策略：决策序列
      * 最优性：最优策略序列的子策略序列总是最优的
      * 思想实质：分治思想和解决冗余
        * 记录重复子问题答案
    * 性质：
      * 最优子结构
      * 重叠子问题
    * 步骤：
      1. 找出最优解的性质
      2. 递归定义最优值(动态规划方程)
      3. 计算最优值：
         * 自顶向下的备忘录法
         * 自底向上
      4. 构造最优解
    * 例子：
      * 组合数
      * 最长公共子序列
      * 多个矩阵相乘
      * 0-1背包问题
      * 多阶段决策问题/多段图
      * Warshall算法：求传递闭包
      * Floyd算法：求所有点之间最短路径

  * 贪心算法：

    * 贪心选择性质：问题的整体最优解可以通过一系列局部最优的选择来达到
    * 方法：自顶向下
    * 步骤：
      1. 选取度量标准，对输入排序
      2. 逐个考虑，直到得到最优解
    * 例子：
      * 背包问题：可以放入物体的一部分，按单位物体价值排序
      * Dijkstra算法
      * 最小生成树：Prim算法，Kruskal算法


---

* 红黑树
  * 数组、链表、二叉树：
    * 数组查找效率高，插入、删除效率低
    * 链表查找效率低，插入、删除效率高
    * 折中，查找、插入、删除效率高
  * 与二叉查找树、平衡二叉树区别
    * 引入原因：
      * 二叉查找树退化成链表
      * 平衡二叉树绝对平衡影响插入删除性能
    * 插入、删除红黑树较优，查找平衡二叉树较优
    * 红黑树相对平衡，旋转次数少，插入最多两次旋转，删除最多三次旋转
  * 性质：
    * 根和叶子黑色
    * 相邻节点不同时为红
    * 红色节点子节点为黑
    * 节点到叶子节点所有路径黑色节点数目相同
  * 插入：
    * 变色
    * 旋转
  * 时间复杂度
* 哈希表：
  * 计算哈希：
    * 直接地址法
    * 除留余数法
    * 平方取中法：关键字平方后中间几位
  * 解决冲突：
    * 开放地址法：
      * 线性探测：每次增加1
      * 二次探测(平方探测)：每次增加步数的平方
      * 双哈希：增加一个哈希函数来生成步长
    * 再哈希法：增加计算时间
    * 链地址法：相同哈希值用链表存储
  * 载荷因子：元素个数/表长度
* 排序：
  * 快速排序
  * Top K：
    * 全局排序
    * 局部排序，冒泡k次
    * 堆排序，大小为k的小顶堆
    * 快排找第k个
  * 洗牌算法：
    * 从0-k随机选一个数放在数组尾部，k：n-1→0
  * 为什么用快排不用归并：
    * 快排大部分情况下是平均情况，很少是最坏情况
    * 实际情况下常量时间不能忽略，归并需要辅助数组，常量时间大
* 搜索：
  * DFS非递归实现
* 空间划分：
  * KD-Tree
* 图论：
  * Dijkstra
  * A*

