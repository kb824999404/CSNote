# 概述

## ch1:概述

* **计算机系统组成：**计算机硬件、操作系统、系统程序与应用程序、用户
* **操作系统定义：**
  * 操作系统是计算机系统中的一个**系统软件**，**管理和控制**计算机系统的**软硬件资源**，合理地**组织**计算机的工作流程，以便有效利用这些资源为用户提供一个功能强、使用方便的**工作环境**，从而在计算机与用户之间起到**接口**的作用。
  * 从不同角度定义：
    * 资源分配器：管理和分配资源
    * 控制程序：控制用户程序的执行和I/O设备的操作
    * 内核程序：在任何时间运行的一个程序(其他所有程序是应用程序)
  * 操作系统的层次定位：向上提供**服务**，向下提供**管理**
  * 计算机逻辑层次：最底层是硬件，上面是操作系统，接着是系统程序，最后是应用程序
* **操作系统设计目标：**
  * 一是使计算机系统使用方便（方便性）
  * 二是使得计算机系统能高效地使用硬件（有效性）
* **现代操作系统的四个基本观点**
  * 计算机用户：
    * **用户环境观点：**
      * 操作系统是计算机用户使用计算机的接口， 为用户提供便捷的工作环境
      * OS提供的接口：用户接口 程序接口
  * 应用程序员：
    * **虚拟机器观点：**
      * 操作系统是建立在计算机硬件平台上的虚拟机器，为应用软件提供更强或硬件不能直接提供的功能
  * OS开发者：
    * **资源管理观点 ：**
      * 操作系统是计算机中各类资源的管理者，负责分配、回收及控制他们。
    * **作业组织观点：**
      * 操作系统是计算机工作流程的组织者， 负责协调系统中运行的各应用软件的运行次序
* **现代操作系统四个特征：**
  * **并发:** 所谓并发，是指两个或两个以上事件在同一时间间隔内发生。
  * **共享:** 所谓共享是指系统中的硬件和软件资源可为多个用户同时使用。
  * **异步性:** 所谓异步性是指内存中的多个进程均按照各自独立的、不可预知的速度向前推进。
  * **虚拟:** 所谓虚拟是指把物理上的一个实体变成逻辑上的多个对应物。
  * 并发和共享是操作系统的两个最基本特征，它们之间是相辅相成、互为依存条件的。
* **操作系统发展阶段：**
  * **作业批处理系统：**批处理把用户提交的作业成批送入计算机，然后由**作业调度程序**自动选择作业运行，以缩短作业间的 交接时间，减少CPU的空闲等待，从而提高系统效率
  * **分时系统：**在分时环境下，一个计算机系统连接有若干个本地或远程终端，每个用户都可以在自己的终端上以交互方式使用计算机，对系统资源进行时间上的分享
  * **并行系统：**紧耦合系统——处理器共享内存和时钟;通信通常通过共享内存进行
  * **分布系统：**松耦合系统——每个处理器都有自己的本地内存;处理器之间通过各种通信线路进行通信，例如高速总线或电话线
  * **实时系统：**实时系统则是指系统对特定输入做出反应的速度足以控制发出实时信号的对象。
* **操作系统发展规律：**
  * 操作系统发展是由**低层硬、软件技术**与上层**应用需求**的发展所推动的
  * 操作系统每一步发展都是权衡的结果 

---

## ch2:硬件环境

* **计算机体系结构：**

  * **冯·诺依曼(普林斯顿结构)：**
    * 一个存储器（数据和指令在一个存储器里）；
    * 一个控制器
    * 一个运算器，用于完成算术运算和逻辑运算
    * 输入和输出设备，用于进行人机通信
  * **哈佛结构：**
    * 数据和指令分开存储器
    * 指令和数据可以有不同的宽度
    * 可以并行存取，具有较高的效率
  * **本质区别：**
    * 冯·诺依曼结构数据和指令合并存储、统一编址；哈佛结构数据和指令分开存储、独立编址

* **现代计算机体系结构：**

  * CPU和I/O设备可以并发执行
  * CPU
    * 获取一条指令并执行它
    * 将数据从主存移到本地缓冲区
  * 设备控制器
    * 负责特定的设备类型
    * 具有本地缓冲区。I/O是从设备到控制器的本地缓冲区
    * 通过引起中断通知CPU它已经完成了操作

* **I/O结构：**

  * 两种I/O方式：
    * 同步：在I/O启动后，只有在I/O完成时，控制才返回到用户程序
    * 异步：在I/O启动后，控制立即返回到用户程序，而不需要等待I/O完成
  * I/O数据交互方式：
    * 程序I/O：由处理器提供I/O相关指令实现处理器定期轮询I/O单元的状态，直到处理完毕
    * 中断I/O：当I/O处理单元准备好与设备交互的时候，通过物理信号通知处理器，即中断处理器
    * DMA：通过系统总线中一独立控制单元——DMA控制器， 自动控制成块数据在内存和I/O单元间的传送，大大提高处理I/O的效能
    * 通道：独立于中央处理器，专门负责数据I/O传输的处理机（I/O处理机），由专门的软件进行管理

* 操作系统是由**中断驱动**的

  * 所有并发程序都是有中断（特别是时钟中断）驱动的，故操作系统中属于这一类的程序也是由中断驱动的。
  * 第二类是直接面对用户态"被动"地为用户服务的程序。系统初启后，这类程序一般是不运行的，仅当用户态程序执行了相应的系统调用时，它才被调用、执行。而正如上面所说，系统调用指令的执行是经中断（自陷）机构处理的。因此，在这种意义上，操作系统中的这一类程序也是由中断驱动的。
  * 第三类是那些既不主动运行，也不直接面对用户态的程序。它们是隐藏在操作系统内部，由前两类程序所调用的程序。既然前两类程序都是由中断驱动的，则此类程序当然也应该是由中断驱动的。

* **存储结构：**

  * 速度

  * 成本

  * 容量

  * 易失性

  * 两种原因导致程序和数据不能长期驻留内存：

    * 内存大小有限
    * 内存是*易失性*存储设备

      所以需要辅助存储器对内存进行扩充

  * Cache：

    * 缓冲三种位置：
      * 处理器与主存储器之间
      * 处理器和其它外部设备之间
      * 设备与设备之间的通信
    * 目的：解决部件之间速度不匹配的问题

* **硬件保护：**

  * Dual-Mode Operation（双操作模式）：
    * *User mode*（用户态或目态） ：用户运行的状态，只能执行非特权指令，访问指定的寄存器和内存储区
    * *Monitor mode* （系统态或核心态或管态）：操作系统运行的状态，允许特权指令执行，访问所有寄存器和内存储区
    * 模式位添加到计算机硬件，以指示当前模式:管态(0)或目态(1)
    * 从目态转换为管态的唯一途径是中断
    * 从管态到目态可以通过修改程序状态字来实现，这将伴随这由操作系统程序到用户程序的转换
  * I/O protection（I/O保护）：
    * 所有I/O指令都是特权指令
    * 必须确保用户程序永远不能获得对目态下的计算机的控制
  * Memory protection（内存保护）
  * CPU protection（CPU保护）

---

## ch3:操作系统结构

* **操作系统组成：**
  * 进程管理
  * 内存管理
  * 辅存外存管理
  * IO管理：
  * 文件管理
  * 保护和安全
  * 网络
  * 命令解释程序
* **操作系统服务：**提供给操作系统设计人员
  * **操作系统提供一个环境以执行程序，它向程序和这些程序的用户提供一定的服务**
  * 基础服务：对用户很有用的函数
    * 程序执行
    * I/O操作
    * 文件系统操作
    * 通信
    * 错误检测
  * 附加函数：不是为了帮助用户而是为了确保系统本身高效运行
    * 资源分配
    * 统计
    * 保护和安全
* **操作系统程序接口（系统调用）：**提供给编程人员
  * **系统调用提供了运行程序和操作系统之间的接口**
  * 定义：所谓系统调用，即用户在源程存一级请求操作系统为之服务的一种手段。它是由操作系统中的一段程序来完成特定功能的，属于一种特殊的过程调用。调用一般用户子程序计算机处于目态，完成系统调用功能要采用一种特殊的调用方式--访管方式来实现
  * 系统调用类型：
    * 进程控制
    * 文件管理
    * 设备管理
    * 信息维护
    * 通信
  * 系统调用过程：当用户在源程序中需要请求操作系统服务时，只需在程序中的适当位置加上一条系统调用命令．当执行到这条命令时，就产生一个访管中断，处理机从目态转为管态，同时控制权转给访管中断处理程序。由访管中断处理程序按相应系统调用命令的功号，通过地址变换找到相应的例行子程序入口去执行。执行完毕后，退出中断，返回到用户程序的断点，恢复现场，继续执行用户程序。
* **操作系统应用程序（系统程序）：**提供给应用程序用户
  * **系统程序提供了一个方便的环境，以开发程序和执行程序**
  * 分类：
    * 文件管理
    * 状态信息
    * 文件修改
    * 程序语言支持
    * 程序装入和执行
    * 通信
    * 应用程序
  * 绝大多数用户所看到的操作系统是由应用程序和系统程序而不是由系统调用所决定的
* **操作系统的两种服务方式：**系统调用、系统程序
* **操作系统结构：**
  * 简单结构：没有被划分成模块
  * 分层方法：操作系统分成若干层，每个层都建立在较低的层之上。底层是硬件，最高层是用户界面。每个层只能利用较低层的功能和服务。
  * 微内核：
    * 精心设计的、能实现现代OS核心功能的小型内核。不是一个完整操作系统，只是为构建通用OS提供基础。
    * 提供一些基本功能，如进程管理、存储器管理、进程间通信、低级I/O功能等
  * 现在微内核结构是以**微内核**为OS核心，以**客户/服务器**为基础，采用**面向对象程序设计**特征。是当今最有发展前途的OS结构。
* **操作系统设计目标：**
  * 用户目标：操作系统应该方便使用，容易学习，可靠，安全，快速。
  * 系统目标：操作系统应该易于设计、实现和维护，以及灵活、可靠、无错误和高效。

---

# 进程管理

## ch4:进程基础

* **进程概念：**
  * **进程定义：**进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动

    * 在操作系统中，**进程**是资源分配、调度和管理的最小单位
    * 进程包括：程序段、代码段、（PCB）
    * **进程**与**程序**区别：
      * **进程更能真实地描述并发，而程序不能**（为什么引入进程的原因）
      * 进程是由程序和数据两部分组成的
      * 程序是静态的，进程是动态的
      * 进程有生命周期，有诞生有消亡，是短暂的；而程序是相对长久的
      * 一个程序可对应多个进程
      * 一个进程也能产生多个进程
      * 进程具有创建其他进程的功能，而程序没有
    * **进程特征：**
      * **并发性：**任何进程都可以同其他进程一起向前推进
      * **动态性：**进程的实质是程序的一次执行过程，有一定的生命期
      * **独立性：**进程是资源分配的一个独立单位
      * **异步性：**每个进程都以其相对独立的、不可预知的速度向前推进
      * **结构性：**进程的组成：程序+数据+PCB
      * (**交互性：**指进程在执行过程中可能与其它进程产生直接或间接的关系)

  * **进程状态：**

    * 新建：进程刚被创建
    * **运行：**当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为运行状态
    * **阻塞：**正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理 机而处于等待状态。
    * **就绪：**当进程已分配到除 CPU 以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
    * 终止：进程执行完毕

    ![processState](E:\常用\课程\操作系统\Pic\processState.png)

  * 进程状态转换：

    ![ststachange](E:\常用\课程\操作系统\Pic\statechange.png)

    * 1. 就绪—运行：
         * **调度程序**选择
         * 一个**新的**进程运行
      2. 运行—就绪：
         * 运行进程**用完**了时间片
         * 运行进程被**中断**，因为一高优先级进程处于就绪状态
      3. 运行—等待：
         * OS**尚未完成**服务
         * 对一**资源的访问**尚不能进行
         * 初始化**I/O** 且必须等待结果
         * 等待某一进程提供**输入** (IPC)
      4. 等待—就绪：
         * 当所等待的事件**发生**时

  * **进程控制块(PCB)：**

    * 系统为了管理进程设置的一个专门的**数据结构**，用它来记录进程的外部特征，描述进程的运动变化过程等
    * 系统利用PCB来**控制**和**管理**进程，所以**PCB是系统感知进程存在的唯一标志**。进程与PCB是**一一对应**的
    * PCB是由**操作系统**维护的
    * PCB包含：（内部属性）
      * **进程标识符信息**
      * **处理器状态信息**
      * **进程控制信息**
    * **PCB组织方式：**系统把所有PCB组织在一起，并放在内存固定区域，就构成了**PCB表**
      * 线性队列
      * 链表
      * 索引表
      * PCB表的大小决定了系统中最多可同时存在的进程个数，称为系统的**并发度**

  * **进程上下文：**

    * 对进程执行活动全过程的静态描述
    * 由进程用户地址空间内容、硬件寄存器内容及与该进程相关的核心数据结构组成

  * **上下文切换：**

    * 当CPU切换到另一个进程时，系统必须保存旧进程的上下文，并为新进程加载保存的上下文
      * 进程的上下文在进程的PCB中表示
    * 上下文切换时间是**开销**;系统在切换时没有任何有用的工作
    * 上下文切换时间主要取决于硬件支持
    * 操作系统程序员尽可能尝试新的结构来减少上下文切换时间

* **进程调度：**

  * 调度类型：
    * **高级调度（长程调度）：**也称为**作业**调度或宏观调度，高级调度的时间尺度通常是分钟、小时或天
    * **中级调度（中程调度）：**涉及进程在**内外存**间的交换。从存储器资源管理的角度来看，把进程部分或全部换出到外存上，可为当前运行进程的执行提供所需内存空间，将当前进程所需部分换入到内存。指令和数据必须在内存里才能被处理机直接访问
    * **低级调度（短程调度）：**也称微观调度，从**处理机资源分配**的角度来看，处理机需要经常选择**就绪进程或线程**进入运行状态。低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效
  * 调度模式：
    * 非剥夺方式：简单、开销小、实时性差
    * 剥夺方式：
      * 剥夺原则：优先级原则 时间片原则
  * 调度算法

* **原语：**

  * 定义：是操作系统中内核中由若干条指令构成，用于完成特定功能的一个过程，该过程在执行时是不可中断的
  * 进程控制原语：是对进程生命期控制和进程状态转换的原语，基于进程的基本状态
    * 进程创建原语create()
    * 进程撤消原语exit()
    * 阻塞原语block()
    * 唤醒原语wakeup()
    * 挂起(移出内存)原语suspend()
    * 激活(移入内存)原语active()
  * 进程创建：
    * 创建方式：
      * 系统程序模块统一创建
      * 父进程创建
    * 资源共享方式：
      * 父进程和子进程共享所有资源
      * 子进程共享父进程资源的子集
      * 父进程和子进程不共享资源
    * 执行方式：
      * 父进程和子进程并发执行
      * 父进程等待，直到子进程执行完
    * 地址空间：
      * 子进程是父进程的复制品（**fork**）
      * 子进程装入另一个新程序（**fork**后**execve**）
  * 父进程让子进程先执行可调用**wait**函数

  * 父进程撤销后，其子进程不能存在
    * 操作系统不允许子进程在父进程终止时继续
    * 发生级联终止

* **进程协作：**

  * **进程间的联系：**
    * **相交进程与无关进程：**
      * 相交进程（协作进程）：指多个并发进程在逻辑上有某种联系
      * 无关进程：即不相交进程，在逻辑上无任何联系的进程。
    * **直接作用和间接作用：**
      * 直接作用：进程间的相互联系是有意识的安排的，只发生在**相交进程**间。（同步、通信）
      * 间接作用：进程间要通过某种中介发生联系，是无意识安排的，可发生在**相交进程**之间，也可发生在**无关进程**之间。（互斥）
  * **进程同步（直接作用）：**
    * 指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。进程间，因为在某些位置上需要协调它们的工作而相互等待、相互交换信息所产生的制约关系。
    * 也可以说是并发进程互相**共享对方的私有资源**而引起的直接制约。
  * **进程互斥（间接作用）：**
    * 进程间因**竞争共享公有资源**而引起的间接制约关系，称为互斥。
    * 间接是指：各并发进程的速度受公有资源制约，而不是进程间直接制约。

* **进程间通信（IPC）：**进程间通信是指进程间的信息交换

  * **通信类型：**
    * **低级通信(定长)：**只能传递状态和整数值
      * 传送信息量小：效率低，每次通信传递的信息量固定，若传递较多信息则需要进行多次通信。
      * 编程复杂：用户直接实现通信的细节，编程复杂，容易出错。
    * **高级通信(变长) ：**能够传送任意数量的数据，对系统实现要求高，但编程简单
      * **共享存储区：**进程共享某些**数据结构**或者**共享存储区**，通过这些空间进行通信
        * **共享数据结构：** 效率低，适合传递少量数据
        * **共享存储区：**高级通信方式，可传输大量数据
      * **消息传递系统：**最广泛一种通信机制，系统为进程提供了两个高级通讯原语send和receive
        * 直接通信：如消息缓冲通信方式，发送进程可将消息直接发送给接收进程
        * 间接通信：如信箱通信方式，发送进程将消息发送到指定信箱中，而接收进程从信箱中取得消息
      * **管道：**也称共享文件方式，基于文件系统，利用一个打开的共享文件连接两个相互通信的进程，文件作为缓冲传输介质

---

## ch5:线程

* **引入原因：**
  * **引入思想：**
    * 进程两个基本特性：资源分配的独立单位、调度的基本单位
    * 将进程资源分配和调度分开，于是引入了**线程**概念。
  * **引入益处：**
    * **创建**一个新线程花费时间和资源少
    * 两个线程的**切换**花费时间少
    * 同一进程内的线程共享内存和文件，因此它们之间相互**通信**无须调用内核
    * 适合多处理机系统（实现真正意义上的**并行**）
* **线程与进程之间的关系：**进程是资源分配的单位，线程是调度的单位
* **线程概念：**
  * **线程定义：**轻量级进程，进程中的一个运行实体，是一个CPU调度单位；资源的拥有者是进程；可由内核控制，也可由用户控制
  * **线程组成：**
    * 基本上不拥有系统资源，存取所在进程的**内存和其他资源**（共享内容）
    * 只包含一些如程序计数器、寄存器和一组栈（独立内容）
    * TCB（线程控制块）
    * 不运行时保存上下文
  * **线程状态：**
    * **创建：**创建进程时，创建一个新线程或者线程创建线程
    * **阻塞：**等待事件后，线程阻塞，处理器调度其它就绪线程
    * **执行**
    * **就绪**
    * **完成：**执行完成后，释放占用的寄存器上下文和栈空间
  * **线程模式：**
    * 单进程、单线程
    * 单进程、多线程
    * 多进程、一个进程一个线程
    * 多进程、一个进程多个线程
* **实现机制：**
  * 用户级线程：
    * 由**应用程序**完成所有线程的管理
      * 通过线程库(用户空间)管理
      * 一组管理线程的过程
  * 内核级线程：
    * 所有线程管理由**核心**完成
    * 没有线程库，但对核心线程工具提供API
    * 核心维护进程和线程的上下文
    * 线程之间的切换需要核心支持
    * 以线程为基础进行调度
  * 两者结合方法：
    * 多对一模型：许多用户级线程映射到一个内核级线程
    * 一对一模型：每个用户级线程映射到一个内核级线程
    * 多对多模型：许多用户级线程映射到同样数量或更小数量的内核级线程

---

## ch6:CPU调度

* **基本概念：**
  * CPU和I/O：
    * 进程执行由CPU执行和I/O等待周期组成，进程在这两个状态之间切换
    * I/O约束程序具有很多短CPU区间
    * CPU约束程序具有少量长CPU区间
  * CPU调度程序（短期调度程序）：
    * 调度程序从内存中选择一个能够执行的进程，并为之分配CPU
    * 调度发生的4种情况：
      1. 进程终止时
      2. 进程从运行态切换到等待态
      3. 进程从运行态切换到就绪态
      4. 进程从等待态切换到就绪态
    * 只发生1、2的调度称为**非抢占**的
    * 否则称为**抢占**的
  * 分派程序：
    * 用来将CPU的控制交给由短期调度程序选择的进程，包括：
      * 切换上下文
      * 切换到用户模式
      * 跳转到用户程序的合适位置，以重新启动程序
    * **分派延迟**：分配程序停止一个进程而启动另一个所要花的时间
* **调度准则：**
  * **CPU使用率：**使CPU尽可能忙
  * **吞吐量：**一个时间单元内所完成的进程数量
  * **周转时间：**从进程提交到进程完成的时间段
  * **等待时间：**进程在就绪队列中等待所花费的时间之和
  * **响应时间：**从提交请求到产生第一响应的时间
  * 优化准则：使CPU使用率和吞吐量最大化，使周转时间、等待时间和响应时间最小化
  * 本书标准：最小化**平均等待时间**（原因：比较好评测？）
* **调度算法：**
  * FCFS（First-Come, First-Served ) （先到先行调度）：
    * 定义：先请求CPU的进程先分配到CPU
    * 优点：最简单，可以用FIFO队列来容易地实现
    * 缺点：平均等待时间通常较长，CPU利用率低
    * 问题：造成**护航效果**：所有其他进程都等待一个大进程释放CPU
    * FCFS调度算法是**非抢占**的
  * SJF（Shortest-Job-First )（最短作业优先调度）：
    * 定义：将每个进程与其下一个CPU区间段相关联，调度是选择具有最短区间的进程
    * 优点：被证明是最佳的，对于给定的一组进程，平均等待时间最小
    * 缺点：没有办法知道下一个CPU区间的长度，不能在短期CPU调度层次上实现
    * SJF调度经常用于**长期调度**
    * SJF算法可能是抢占的或非抢占的
      * 非抢占SJF
      * 抢占SJF（SRTF最短剩余时间优先调度）：如果一个新进程到达时CPU区间长度小于当前执行进程的剩余时间，抢占
  * Priority Scheduling（优先级调度）：
    * 定义：每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU
    * 优点：优先级可通过内部或外部方式来定义，可考虑多种因素
    * 问题：
      * **饥饿：**某个低优先级进程无穷等待CPU
        * 解决：老化：进程的优先级随时间增加
      * **优先级倒置：**低优先级比高优先级先执行，使得高优先级执行超过时限
        * 解决：优先级继承，当低优先级任务阻塞高优先级任务时，将低优先级任务的优先级提高到被它阻塞任务中最高优先级的优先级别
    * SJF属于简单优先级算法，其优先级为下一个CPU区间的倒数
    * 优先级调度算法可能是抢占的或非抢占的
  * RR (Round Robin ) （轮转法调度）：
    * 定义：每个进程得到一个同样大小的时间片，在这个时间片内如果进程执行结束了，那么把进程从进程队列中删去，如果进程没有结束，进程被抢占并加入就绪队列尾部
    * 优点：n个进程且时间片为q，每个进程的等待时间不会超过(n-1)q个时间单元；有更好的响应
    * 缺点：RR算法的性能很大程度上依赖于时间片的大小，如果时间片非常大，就和FCFS算法一样；如果时间片很小，进程切换的开销太大
    * RR算法适用于**分时系统**
  * Multilevel Queue（多级队列调度）：
    * 定义：将就绪队列分成多个独立队列，一个进程被永久地分配到一个队列，每个队列有自己的调度算法，队列之间必须有调度
    * 多级反馈队列调度（Multilevel Feedback Queue）：允许进程在队列之间移动
    * 优点：能够满足各类用户的需要
* **多处理器调度：**
  * 非对称多处理：简单，因为只有一个处理器访问系统数据结构，减少了数据共享的需要
    * 缺点：主处理器的失败将导致整个系统的失败；由于主处理器必须负责所有的进程调度和管理，因此可能成为性能瓶颈
  * 对称多处理：每个处理器自我调度，每个处理器的调度程序都检查共同就绪队列，以便选择执行一个进程，必须确保两个处理器不会选择同一进程，而且进程不会从队列中丢失
* **算法评估：**
  * 确定性建模
  * 排队模型
  * 模拟 
  * 实现

---

## ch7:进程同步

* **临界区问题：**

  * **临界资源：**系统中某些资源一次只允许一个进程使用，这样的资源为临界资源或互斥资源

  * **临界区：**在进程中涉及到临界资源的程序段叫临界区

    * 进入区
    * 退出区
    * 剩余区：代码中的其余部分

    ![section](E:\常用\课程\操作系统\Pic\section.png)

  * 临界区使用原则：

    * **互斥访问**
    * **有空让进**：当无进程处于临界区时，必须让一个要求进入它的临界区的进程立即进入，以
      提高临界资源的利用率
    * 无空等待：当已有进程处于临界区时，其他试图进入自己临界区的进程必须等待，以保证
      它们互斥地进入临界区
    * 多中择一
    * **有限等待**：对要求进入临界区的进程，应在有限时间内进入，以免陷入"死等"
    * 让权等待：处于等待状态的进程应放弃占用CPU，以使其他进程有机会得到CPU的使用权

  * **进程互斥方法：**

    * **软件方法：**
      * 基本思路：
        * 在进入区检查和设置一些**标志**，如果已有进程在临界区，则在进入区通过循环检查进行等待；在退出区修改标志
        * 主要问题是**设置什么标志**和**如何检查标志**
        * 为了简单说明，算法中只涉及**两个**协作进程
      * 单标志位
      * 双标志位（先检查）
      * 双标志位（先修改）
      * 先修改、后检查、后修改者等待
      * **软件算法缺点：**
        * 忙等待
        * 实现过于复杂，需要高的编程技巧
    * 硬件方法（原子操作）：
      * “测试并设置”指令
      * “交换”指令
      * “开关中断”指令
      * 优点：
        * 适用于任意数目的进程，在单处理器或多处理器上均适用
        * 简单，容易验证其正确性
        * 可以支持进程内存的多个临界区，只需为每个临界区设立一个布尔变量
      * 缺点：
        * 等待要耗费CPU时间，不能实现“让权等待”
        * 可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上
        * 可能死锁

* **进程同步：**

  * 同步机制：

    * OS可从进程管理者的角度来处理互斥同步问题，这就是**同步机制**
    * 同步机制：
      * 信号量P、V操作
      * 管程（资源管理模块）
      * 条件临界域等

  * 信号量：

    * 定义：

      * OS利用信号量对进程和资源进行控制和管理
      * 信号量表示资源的实体，是一个与队列有关的整型变量
      * 其数据结构包含信号量的**值**和阻塞在该信号量的各个进程的标识**队列**
      * 信号量只能通过**初始化**和**P/V原语**来访问，不受进程调度的打断

    * 作用：可用信号量来解决 n 个进程互斥进入各自的临界区对临界资源访问的问题，也可以用信号量控制进程同步间的推进顺序等。

    * 信号量分类：

      * **公用信号量**用来实现进程间的**互斥**，初值为1，允许它所联系的一组进程对它执行P/V操作
      * **私用信号量**用来实现进程间的**同步**，初值为0或者某个正整数，仅允许拥有它的进程对其执行P/V操作。

    * **信号量的值：**信号量取值为非负值表示当前空闲资源数，若为负值其绝对值表示当前等待临界区的进程数

    * P/V操作：

      * P原语（wait）：

        ```
        P（S）
        	1.S=S-1
         	2.如果s>=0,则调用P(S)的进程继续运行
         	3.如果s<0,则调用P(S)的进程被阻塞，并把它插入到等待信号量S的阻塞队列中
        ```

        * 执行P操作意味着**申请**分配一个单位的资源

      * V原语（signal）：

        ```
        V（S）
        	1.S=S+1
         	2.如果s>0,则调用V(S)的进程继续运行
         	3.如果s<＝0,则从等待信号量s的阻塞队列中唤醒头一个进程到就绪队列中，然后调用v(s)的进程继续运行。
        ```

        * 执行V操作意味着释放一个单位的资源
        * V操作用于释放资源（或使用权）， 执行V原语时需要唤醒一个阻塞进程

    * 信号量的物理含义：

      * S>0 表示有S个资源可用
      * S=0 表示无资源可用
      * S<0 则|S|表示S等待队列中的进程个数

    * PV操作必须成对出现

      * 当为**互斥操作**时，它们同处于同一进程
      * 当为**同步操作**时，则不在同一进程中出现
      * 如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要。

    * 优缺点：

      * 简单，而且表达能力强
      * 不够安全，使用不当会出现死锁
      * 遇到复杂同步互斥问题时实现复杂

* 典型同步互斥问题：

  * 生产者－消费者问题
  * 读者写者问题
  * 哲学家就餐问题

* 注意事项：

  * 进程应该先申请资源信号量，再申请互斥信号量，顺序不能颠倒。
  * 对任何信号量的P/V操作必须配对使用。同一进程中的多对P/V语句只能嵌套，不能交叉。
  * 对同一信号量的P/V操作可以不在同一进程中。
  * P/V语句不能颠倒顺序。

---

## ch8:死锁

* **死锁原因：**
  * 一组阻塞的进程，每个进程都持有一个资源并等待获取集合中另一个进程所拥有的资源
  * 资源竞争，是进程对资源要求在时间上的冲突
  * 竞争可能产生死锁，但不一定会死锁。取决于各个进程推进的速度和对资源请求的顺序
* **死锁的四个必要条件：**
  * 互斥
  * 占有并等待：一个进程占有至少一个资源，并等待另一个资源，而该资源被其他进程所占有
  * 非抢占：资源不能被抢占，只能在进程完成任务后自动释放
  * 循环等待：有一组等待进程{P0, P1,…, P0},P0等待的资源被P1占有, P1等待的资源被P2占有,…, Pn-1等待的资源被Pn占有, Pn等待的资源被P0占有
* **资源分配图：**
  * 资源分配图没有环$\Rightarrow$不处于死锁状态
  * 资源分配图有环$\Rightarrow$
    * 如果一种类型的资源只有一个实例，处于死锁状态（充分必要条件）
    * 如果一种类型的资源有多个实例，可能处于死锁状态（必要非充分条件）
* **死锁处理方法：**
  * 三种方法：
    * 预防或避免死锁，确保系统不会进入死锁状态
    * 可允许系统进入死锁状态，然后检测它，并加以恢复
    * 忽视这个问题，认为死锁不会发生
    * 为什么大多数操作系统不解决死锁问题：
      * 对许多系统来说，死锁很少发生，因此，与使用频繁的并且开销昂贵的死锁预防、死锁避免和死锁检测与恢复相比，这种方法更为便宜
  * **死锁预防：**4个必要条件，只有确保至少一个必要条件不成立，就能预防死锁发生
    * 互斥
    * 占有并等待
    * 非抢占
    * 循环等待
  * **死锁避免：**动态地检测资源分配状态以确保循环等待条件不可能成立
    * 安全和不安全状态
    * 资源分配图算法（需求边）
  * **死锁检测：**用来检测系统状态从而确定是否出现了死锁的算法
    * 等待图：所有资源类型只有单个实例，从资源分配图中，删除所有资源类型节点，合并适当的边
    * 当且仅当等待图中有一个环，系统中存在死锁
  * **死锁恢复：**用来从死锁状态中恢复的算法
    * 进程终止：
      * 终止所有死锁进程
      * 一次只终止一个进程直到取消死锁循环为止
    * 资源抢占：
      * 选择一个牺牲品
      * 回滚
      * 饥饿

---

# 内存管理

## ch9:内存管理基础

* 程序执行之前：
  * 编译：**编译程序**将用户代码编译成若干个目标模块
  * 链接：**链接程序**将编译后形成的一组目标模块，以及所需要的库函数链接在一起，形成完整的装入模块
  * 装入：由**装入程序**将装入模块装入内存

* 地址的表现形式：
  * 符号(源程序中)
  * 可重定位的地址(目标模块)
  * 装入模块(相对地址)
  * 绝对地址(内存映像)

* **程序链接技术：**

   * **静态链接：**程序运行之前，将各目标模块及所需函数，链接成为一个完整的装入模块，以后不再拆开
   * 动态链接：
      * **装入时动态链接：**一组目标模块，在装入内存时，边装入边链接。
      * **运行时动态链接：**程序执行中需要该目标模块时，才进行链接
   * 优缺点：
      * 动态链接节省空间
      * 动态链接增加程序可扩展性、兼容性
      * 动态链接速度慢
   * 链接解决的问题：
      * 对相对地址进行修改
      * 变换外部调用符号

* 引入**地址空间**的原因：

   * 安全性：如用户程序可以直接寻址物理内存，有可能会破坏操作系统（有意或无意）
   * 并发度：采用程序的逻辑地址空间可以较方便的同时运行多个程序

* 地址空间(逻辑地址)和存储空间(物理地址)

   * **名空间：**把程序中由符号名组成的空间称为名空间
   * 逻辑地址空间和存储空间
      * CPU所生成的地址通常称为**逻辑地址**
      * 内存单元看到的地址通常称为**物理地址**
      * **逻辑地址空间**(简称**地址空间**)是逻辑地址的集合
      * **物理地址空间**(简称**存储空间**)是物理地址的集合
      * 各进程的地址空间是相互独立的

* **程序装入技术:**

   * 地址再定位技术:
      * 将逻辑地址和物理地址对应起来的过程
      * 地址再定位由操作系统中的**装入程序**来完成
   * 常用程序装入技术：
      * 绝对装入技术：
         * 也称为**固定地址再定位**，程序地址再定位在执行之前被确定，也就是在**编译链接**时直接制定程序在执行时访问的实际存储器地址
         * 程序地址空间和内存地址空间是一一对应
         * 优点：装入过程简单
         * 缺点：过于依赖于硬件结构，不适于多道程序系统
      * 可重定位装入技术
        * 可执行文件中，列出各个需要重定位的地址单元和相对地址值，**装入时**再根据所定位的内存地址去修改每个重定位地址项，添加相应偏移量
        * **静态再定位：**
           * 由装入程序在**程序执行之前**进行地址再定位，地址定位完成后，在程序执行期间不会发生变化
           * 优点：易实现，**无需硬件支持**
           * 缺点：
              * 程序再定位后就不能移动，因而不能重新分配内存，不利于内存的有效利用。
              * 程序在存储空间中只能**连续分配**，不能分布在内存的不同区域。
        * **动态再定位：**
          * 程序装入内存时，不修改逻辑地址，在访问物理内存之前，再**实时地**将逻辑地址转换成物理地址
          * 优点：
            * 程序在**执行过程中可以移动**，有利于内存充分利用
            * 程序不必连续存放在内存中，可**分散在内存**若干个不同区域，只需增加几对基址或界限寄存器，每对寄存器对应一个区域
          * 缺点：
             * 需要附加**硬件支持**，实现存储管理的软件算法比较复杂

* 存储管理：

   * **目的：**
     * 充分利用内存
         * 尽可能方便用户使用
     * 存储保护与安全
     * 共享与通信
     * 实现的性能和代价
         * 解决程序空间比实际内存空间大的问题
   
* **任务：**
  
  * 存储**分配**和**回收**
   * 存储**共享**
      * 存储**保护**
   * 存储器**扩充**
  
 * **存储管理方案：**

    * **连续分配方式：**
       * 单一连续存储管理
       * 分区存储管理
    * **离散分配方式：**
       * 分页存储管理（分配单位是页）
       * 段式存储管理（分配单位是段）
       * 段页式存储管理
    * 虚拟存储器

* **连续分配方式：**

   * 基本思想：内存通常分为两个区域：一个用于驻留操作系统，通常和中断向量放在低内存；一个用于用户进程，位于高内存
   * 单一连续存储管理：
      * 基本思想：整个内存空间分成**系统区**和**用户区**，系统区给操作系统使用，用户区给用户使用。
      * 适用场合：最简单，适用于单用户、单任务的OS
      * 优点：易于管理
      * 缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。
   * 分区存储管理：
      * 基本原理：
         * 把内存分为一些大小相等或不等的分区，每个应用进程占用一个或几个分区。操作系统占用其中一个分区
         * 特点：
            * 适用于多道程序系统和分时系统
            * 支持多个程序并发执行
         * 问题：
            * 可能存在内碎片和外碎片
            * 难以进行内存分区的共享
         * 数据结构：分区表，或分区链表
            * 空闲分区表，占用分区表
            * 空闲分区表中按不同分配算法相应对表项排序
      * 固定分区：
         * 基本思想：内存划分为若干个固定大小的连续分区
            * 分区大小相等：适合于多个相同程序的并发执行（处理多个类型相同的对象）
            * 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区
         * **优点：**
            * 比单一连续分配方法，内存利用率提高了
            * 可以支持多道程序
            * 实现简单
         * **缺点：**
            * 作业必须预先能够估计自己要占用多大的内存空间
            * 内碎片造成浪费
            * 分区总数固定，限制了并发执行的程序数目
      * 动态分区：
         * 基本原理：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小
         * 优点：没有内碎片
         * 缺点：有外碎片
      * 评价：
         * 优点：
            * 实现了主存共享，有助于多道程序设计
            * 动态分区主存利用率比固定分区高些
            * 相对于后面介绍的存储管理方式，本方案为实现分区分配所使用的表格，占用存储容量相对较少，算法也相对简单
            * 实现存储保护的措施也比较简单
            * 多重分区分配方案能实现对子程序、数据段的共享
         * 缺点：
            * 主存仍不能充分利用，除了采用紧凑技术外，都存在着严重碎片
            * 不能实现对主存扩充
            * 和单一连续分配一样，要求一个作业执行前必须全部装入主存

* **常用分区分配算法：**

   * **最先适配算法：**
      * 算法思想：按分区先后次序，从头查找，找到符合要求的第一个分区。
      * 算法实质：尽可能利用存储区低地址空闲区，尽量在高地址部分保存较大空闲区，以便一旦有分配大空闲区要求时，容易得到满足
      * 算法优点：分配简单，合并相邻空闲区也比较容易
      * 算法缺点：查找总是从表首开始，前面空闲区往往被分割的很小时，满足分配要求的可能性较小，查找次数较多
      * 解决方法 ：针对这个问题，对最先适应法稍加改进，就有了循环最先适应法
   * **循环最先适配算法：**
      * 算法思想：按分区先后次序，从上次分配的分区起查找（到最后分区时再回到开头），找到符合要求的第一个分区
      * 算法特点：算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留
   * **最佳适配算法：**
      * 算法思想：在所有大于或者等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。分配后，所剩余的块会最小
      * 算法实现：空闲存储区管理表采用从小到大的顺序结构
      * 优点：较大的空闲分区可以被保留
      * 缺点：空闲区是按大小而不是按地址顺序排列的 ，因此释放时，要在整个链表上搜索地址相邻的空闲区，合并后，又要插入到合适的位置
   * **最坏适配算法：**
      * 算法思想：分区时取所有空闲区中最大的一块，把剩余的块再变成一个新的小一点的空闲区
      * 算法实现：空闲区按由大到小排序
      * 优点：分配时，只需查找一次，就可成功，分配算法很快
      * 缺点：最后剩余分区会越来越小，无法运行大程序
   * **分区算法存在的问题：**
      * 碎片问题：
         * 经过一段时间分配、回收后，内存中存在很多很小的空闲块，小到不足以满足分配要求；但其总和满足分配要求。这些空闲块被称为碎片，碎片造成存储资源浪费（**外碎片**）
         * 解决方法：**紧凑技术**
            * 通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域
            * 系统开销大
            * 从而，引出了**离散分配方式** 
      * 分区保护

* **碎片：**

   * **外碎片：**是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域
   * **内碎片：**是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间

* **内存扩充技术：**

   * 问题提出：
      * 一个作业的程序地址空间大于内存可使用空间时，该作业就不能装入运行
      * 当并发运行作业的程序地址空间总和大于内存可用空间时，多道程序设计实现就会碰到非常大的困难
   * 内存扩充：借助大容量辅存在逻辑上实现内存扩充，来解决内存容量不足的问题
   * 扩充技术：
      * 覆盖技术：
         * 基本原理：
            * 一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间
            * 将程序的必要部分代码和数据常驻内存
            * 可选部分在其他程序模块中实现，平时存放在外存中（覆盖文件），需要用到时才装入到内存
            * 不存在调用关系的模块不必同时装入到内存，可相互覆盖
         * 缺点：
            * 编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度（没有程序员愿意做这样的事）
            * 从外存装入覆盖文件，以时间延长来换取空间节省
      * 交换技术：
         * 原理：把内存中暂时不能运行或暂不能用的程序和数据，调出到外存上，以便腾出足够内存空间给其它进程或程序使用
         * 交换方式：
            * 整体交换：也称为**进程交换**，交换是以整个进程为单位，**目的是解决内存紧张问题，进一步提高内存利用率**
            * 部分交换：也称为**页面交换**、**分段交换**，是分页、分段交换的基础，**目的是为了支持虚拟存储系统**
         * 优点：
            * 增加并发运行的程序数目；
            * 给用户提供适当的响应时间；
            * 编写程序时不影响程序结构
         * 缺点：换入和换出的控制增加处理机开销
   * 两种技术比较：
      * 覆盖技术主要用在早期操作系统中，交换技术广泛用于分时系统，其发展导致了虚存技术的出现；
      * 覆盖发生在同一进程或作业内，交换发生在进程或作业之间；
      * 覆盖只能覆盖那些与覆盖段无关的程序段，交换技术不要求用户给出程序段之间的逻辑覆盖结构

* **离散分配方式：**

   * **页式存储管理：**

      * 基本原理：
         * 用户空间划分：
            * 把用户程序按逻辑页划分成大小相等的部分，称为页（虚页）。从0开始编制页号，页内地址是相对于0编址
            * 用户空间划分是由系统自动完成的，对用户是透明的。一般，页大小为2的整数次幂，因此，地址的高位部分为页号，低位部分为页内地址
         * 内存空间划分：按页的大小划分为大小相等的区域，称为内存块（物理页面，页框、实页）
         * 内存分配：以页为单位进行分配，并按作业的页数多少来分配。逻辑上相邻的页，物理上不一定相邻
      * 存储管理：
         * 进程页表：
            * 系统为每个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系；
            * 页表放在内存，属于进程的现场信息
         * 物理页面表：
            * 整个系统有一个物理页面表，描述物理内存空间的分配使用状况
            * 数据结构：位示图（适用固定分区），链表（适用动态分区）
         * 请求表：整个系统有一个请求表，描述系统内各个进程页表位置和大小，用于地址转换，也可结合到各进程PCB里
      * 管理过程：
         * 计算一个作业所需要的总块数N
         * 查位示图，看看是否还有N个空闲块
         * 如果有足够的空闲块，则页表长度设为N，可填入PCB中；申请页表区，把页表始址填入PCB
         * 依次分配N个空闲块，将块号和页号填入页表
         * 修改位示图
      * 硬件支持：
         * 系统设置一对寄存器：
            * 页表始址寄存器
            * 页表长度寄存器
         * 联想寄存器——快表（TLB）：为缩短查找时间，可将页表从内存装入到关联存储器，按内容查找，即逻辑页号－>物理页号。
      * 页表结构：
         * 大的逻辑地址空间->大页表
         * 解决办法：
            * 层次化分页（多级页表）：减少页表所占的连续内存空间
            * 哈希页表
            * 反向页表：对于每个真正的内存页或帧才有记录
               * 优点：减少页表大小
               * 缺点：反向页表按物理地址排序，而程序是按逻辑地址执行导致访问顺序和执行顺序不一致
      * 评价：
         * 优点：
            * 解决了碎片问题
            * 便于管理
         * 缺点：
            * 不易实现程序共享
            * 不便于动态链接

   * **段式存储管理：**

      * 引入目的：满足用户编程和使用上的多方面要求
         * 方便编程
         * 信息共享
         * 信息保护
         * 动态增长
      * 基本原理：
         * 用户空间划分：
            * 按程序自身的逻辑关系划分为若干个程序段；
            * 每个程序段都有一个段名，对应一个段号；
            * 段号从0开始，每一段也从0开始编址，段内地址是连续的。
         * 内存空间划分：
            * 内存空间被动态的划分为若干个长度不相同的区域，这些区域被称为物理段；
            * 每个物理段由起始地址和长度确定。
         * 内存分配：
            * 以段为单位分配内存，每一个段在内存中占据连续空间；
            * 各段之间可以不连续存放
      * 存储管理：
         * 进程段表：
            * 记录段号，段的首（地）址和长度；
            * 每一个进程一个段表，属于进程的现场信息，放在内存
         * 系统段表：
            * 系统内所有占用段
         * 空闲段表：
            * 记录空闲段起始地址和长度，可以结合到系统段表中
         * 内存分配算法
      * 硬件支持：
         * 系统设置一对寄存器：
            * 段表始址寄存器：保存正在运行进程的段表始址
         * 段表长度寄存器：用于保存正在运行进程的段表长度
         * 联想存储器
      * 评价：
         * 优点：
            * 便于动态申请内存
            * 管理和使用统一化
            * 便于共享
            * 便于动态链接
         * 缺点：产生碎片

   * 页式和段式比较：

      * 分页是出于系统管理需要，分段是出于用户应用需要
      * 一条指令或操作数可能跨越两个页的分界处，而不会跨越两个段的分界处
      * 页大小是系统固定的，而段大小则通常不固定
      * 逻辑地址表示：
         * 分页是一维的，各个模块在链接时必须组织成同一个地址空间
         * 分段是二维的，各个模块在链接时可以每个段组织成一个地址空间
      * 通常段比页大，因而段表比页表短，可以缩短查找时 间，提高访问速度

   * **段页式管理：**

      * 基本思想：

         * 用户程序按段式划分

         * 内存空间采用页式存储管理方案

         * 内存分配：以页为单位进行分配

         * 80486存储器分段分页机制示意图：

            ![x86](E:\常用\课程\操作系统\Pic\x86.jpg)

      * 存储管理：

         * 段表：记录每一段的页表始址和页表长度
         * 页表：记录了逻辑页号与内存块号的对应关系（每一段有一个，一个程序可能有多个页表）
         * 空块管理同页式管理
         * 分配同页式管理

      * 硬件支持：

         * 段表始址寄存器  
         * 段表长度寄存器  
         * 相联存储器（快表）

---

## ch10:虚拟内存管理

* **虚拟内存：**
  * 工作原理：
    * **在程序装入时**，只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。
    * **在程序执行过程中**，需执行的指令或访问的数据尚未在内存（称为**缺页**或**缺段**），则由处理器通知操作系统将相应的页或段调入到内存，然后继续执行程序。
    * **另一方面**，操作系统将内存中暂时不使用的页或段调出保存在外存上，腾出空间存放将要装入的程序以及将要调入的页或段。（交换技术）
  * 引入好处：
    * 大程序：可在较小的可用内存中执行较大的用户程序
    * 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存
    * 并发：可在内存中容纳更多程序并发执行
    * 易于开发：与覆盖技术比较，不必影响编程时的程序结构
  * 虚拟存储特征：
    * **不连续性：**
      * 物理内存分配的不连续;
      * 虚拟地址空间使用的不连续。
    * **部分交换：**与整体交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的
    * **大空间：**通过物理内存和快速外存相结合，提供大范围的虚拟地址空间，总容量不超过物理内存和外存交换区容量
* **虚拟页式：**
  * 页表项结构：
    * 页号 中断位 内存块号 保护位 访问位 修改位
    * 可采用两级或多级页表
    * 为缩短查找时间，多级页表中的每级都可以装入到联想存储器TLB（快表）中，并按照Cache原理进行更新
  * 中断处理：
    * 保护中断：读/写位和用户/超级用户位等**保护位**不用于地址转换，用于保护机制
    * 缺页中断：
      * 地址映射过程中，在页表中发现所要访问的**页不在内存**，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，将该页从外存调入内存，使作业继续运行下去
      * 如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号
      * 如果内存中没有空闲块，则页面置换
  * 页面置换算法：需要调入页面时，选择内存中哪个物理页面被置换
    * 先进先出算法(FIFO)：
    * 最佳算法（OPT-optimal）：
    * 最近最久未使用算法(LRU-Least Recently Used)：
    * 最不常用算法(LFU-Least Frequently Used)：
    * 轮转算法(clock)：
  * 缺页率：
    * 缺页率＝缺页次数/访问总次数
    * 如何保证低缺页率：
      * 提高预测准确度
      * 增加页框数
  * 性能问题：
    * Belady现象：
      * 采用置换算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的**异常现象**
      * 原因：算法的置换特征与进程访问内存的动态特征发生矛盾时，即被置换的页面并不是进程不会访问的
* **虚拟存储策略：**
  * 调入策略：
    * 请求调页：只调入发生缺页时所需的页面
      * 优点：容易实现
      * 缺点：对外存I/O次数多，开销较大
    * 预调页：发生缺页，需要调入某页时，一次调入该页以及相邻的几个页
      * 优点：提高调页的I/O效率
      * 缺点：基于预测，若调入的页在以后很少被访问，则效率低。常用于程序**装入时**的调页
  * 分配策略：
    * 虚拟段式管理中，对物理内存进行分配，可采用最佳适应、最先适应等动态分区分配方法
    * 虚拟页式和段页式管理中，地址变换最后通过页表进行，因此不必考虑分配策略
  * 清除策略：
    * 页面清除：将由页面置换算法选择的**被修改**的置换页面**保存到外存**
    * 清除策略需要决定系统**何时**把被置换页面写回外存
    * 请求清除：该页被置换时才调出，把清除推迟到最后一刻
      * 缺点：调入所缺页面之前还要调出已修改页面，缺页进程的等待时间较长
    * 预清除：该页被置换之前就调出，因而可以成批调出 多个页面
      * 缺点：可能形成不必要的开销
* **系统颠簸（页面抖动）：**
  * 刚被淘汰出去的页很快又被访问，需要重新调入；但是，调入不久又再次被淘汰出去。如此反复，使得整个系统的**页面替换非常频繁**，使大部分机器时间都用在来回进行的页面调度上，这种局面称为系统颠簸
  * 结果：
    * 缺页率急剧增加；
    * 内存有效存取时间加长；
    * 系统吞吐量骤减；
    * 系统已基本不能完成什么任务

---

# 文件管理

## ch11:文件系统

* **引入原因：**计算机应用程序都要**存储信息**和**检索信息**
* 能够存储大量的信息
  * 长期保存信息
  * 可以共享信息
  
* **文件定义：**一组带标识的、在逻辑上有完整意义的信息项的序列。其中：
* 标识是文件名；
  * 信息项是构成文件内容的基本单位；
  * 长度是单个字节或多个字节；
  * 文件内容由文件建立者和使用者解释；
  * 文件的各信息项之间具有顺序关系
  
* **文件系统：**
* 是操作系统中统一管理信息资源的一种软件。
  * 管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用
  * 文件系统的功能：
    * 统一管理文件的存储空间，实施存储空间的分配与回收。
    * 实现文件的按名**存取**：名字空间映射到存储空间
    * 实现文件信息的**共享**，并提供文件**保护**和保密措施
    * 向用户提供方便使用的接口：
      * 如提供对文件系统操作命令、提供对文件的操作命令：信息存取、加工等
    * 系统维护及向用户提供有关信息
    * 文件系统的执行效率
    * 提供与I/O的统一接口
  
* **文件属性：**
* 名称
  * 标识符
  * 类型
  * 位置
  * 大小
  * 保护
  * 时间、日期和用户标识
  
* **文件操作：**
* 创建文件
  * 写文件
  * 读文件
  * 在文件内重定位
  * 删除文件
  * 截短文件
  
* **文件结构：**
* **逻辑结构：** 从用户角度研究文件的组织形式
    * 文件的逻辑结构与存储设备特性无关
    * 无结构文件（流式文件）：
      * 构成文件的基本单位是字符，文件是有逻辑意义的、无结构的一串字符的集合。
      * 文件：一个无结构字节序列
      *  好处：提供很大的灵活性
    * 有结构文件（记录式文件）：
      * 文件是由若干个记录组成，每个记录有一个键，可按键进行查找,适用快速定位
      * 文件：一个固定长度记录的序列，每条记录有其内部结构。
  * **物理结构**：从系统角度来看文件，从文件在物理介质上的存放方式来研究文件
    * 文件的物理结构与存储设备特性关系紧密
    * **连续（顺序）结构：**
      * 文件信息存放在若干连续的物理块中，如磁带等
      * 优点：
        * 简单 
        * 支持顺序存取和随机存取
        * 顺序存取速度快
        * 所需的磁盘寻道次数和寻道时间最少
      * 缺点：
        * 文件不能动态增长
        * 预留空间:浪费
        * 重新分配和移动
        * 不利于文件插入和删除
        * 外部碎片问题
        * 存储压缩技术
    * **链接结构：**
      * 文件信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块
      * 优点：
        * 提高了磁盘空间利用率,不存在外部碎片问题
        * 有利于文件插入和删除
        * 有利于文件动态扩充
      * 缺点：
        * 存取速度慢，不适于随机存取
        * 可靠性问题，如指针出错
        * 更多的寻道次数和寻道时间
        * 链接指针占用一定的空间
    * **索引结构 ：**
      * 文件信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构--**索引表**，并将这些块的块号存放在一个索引表中
      * 优点：
        * 保持了链接结构的优点,又解决了其缺点： 
        * 即能顺序存取,又能随机存取
        * 满足了文件动态增长、插入删除要求
        * 能充分利用外存空间
      * 缺点：
        * 较多的寻道次数和寻道时间
        * 索引表本身带来了系统开销
    * 索引表组织：
      * 链接模式：一个盘块一个索引表,多个索引表链接起来
      * 多级索引：将一个大文件的所有索引表（二级索引)的地址放在另一个索引表（一级索引)中
      * 综合模式：
        * 每个文件索引表为13个索引项，每项2个字节。最前面10项直接登记存放文件信息的物理块号（直接寻址）
        * 如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址
        * UNIX采用了三级索引结构
  
* **文件目录结构：**
* **文件控制块（FCB）：**
    * 文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息（文件属性）
    * 文件控制块是文件存在的标志
    * 目录项内容：
      * 基本信息：文件名、类型、组织等；
      * 地址信息：卷(存储文件设备)、起始地址、长度等；
      * 访问控制信息：所有者、访问信息(用户名及口令等)、合法操作等；
      * 使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近修改时间等
  * 文件目录：把所有FCB组织在一起，就构成了文件目录，即文件控制块的有序集合
  * 目录项：构成文件目录的项目（目录项就是FCB）
  * 目录文件：为实现对文件目录的管理，通常将文件目录以文件形式保存在外存，这个文件就叫目录文件
  
* **目录结构：**
* 目的：使用文件目录使得文件之间的组织结构清晰，易于查找；编程时也可以很方便地使用文件路径找到一个文件，用户可以很轻松地实现按名存取
  * 一级目录结构
  * 二级目录结构
  * **多级目录结构：**
    * 系统将**当前工作目录**中的内容复制到内存缓冲区中，在访问文件时先访问内存中的工作目录。当要访问的文件不在当前目录中时，再访问外存中的目录，提高了查找速度
    * 优点：
      * 层次结构清晰，便于管理和保护
      * 有利于文件分类
      * 解决重名问题
      * 提高文件检索速度
      * 能进行存取权限的控制
    * 缺点：
      * 查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。
      * 不利于文件共享
  * 无环图目录
  * 通用图目录
  * 哈希表算法
  * 其他算法：B+树
  
* **目录结构改进：**
* 改进目的：加快目录检索
  * 改进方法：采用目录项分解法，把FCB分成两部分
    * 符号目录顶（次部）：文件名，文件号
    * 基本目录项（主部）：除文件名外的所有项目
  
* **磁盘空闲区管理：**
* 数据结构：
    * 空闲块表----适合建立连续文件：所有空闲块记录在一个表中
    * 空闲块链表：把所有空闲块链成一个链
  * 管理方法：
    * 位示图法： 用一串二进制位反映磁盘空间中的分配使用情况, 每个物理块对应一位, 分配物理块为1，否则为0
    * 成组链接法 ：是对空闲块链表进行改进，将空闲块分成若干组，用指针将各组相连，以提高管理效率
  
* **文件系统实现：**
* 数据结构：
    * 系统文件表：系统打开文件表（整个系统一张）放在内存，用于保存已打开文件的FCB文件号、共享计数、修改标志
    * 用户文件表 ：每个进程一个，进程的PCB中，记录了用户打开文件表的位置
    * 两种表间的关系：
      * 用户打开文件表指向系统打开文件表
      * 多个进程共享同一个文件，则多个用户打开文件表目对应系统打开文件表的同一入口
  
* **文件实现：**
* 文件执行：
    * Create()
    * Open()
    * Read()
  * **文件共享：**
  * 定义：一个文件被多个用户或程序使用
  * 共享形式：
      * 被多个用户使用，由存取权限控制
      * 被多个程序使用，但各用自己的读写指针
      * 被多个程序使用，但共享读写指针
    * 目的：
      * 节省时间和存储空间，减少了用户工作量
      * 进程间通过文件交换信息

---

## ch13:磁盘结构

* 常用外存：
  * 磁带：
    * 顺序存取设备
  * 磁盘：
    * 软盘
    * 硬盘：
      * 是重要的外部存储设备之一
      * 直接（随机）存取设备
* **磁盘调度：**
  * **访盘时间：**一次访盘时间 = 寻道时间+旋转延迟时间+存取时间
    * 寻道时间：磁头移动
    * 延迟时间：磁盘转动
    * 存取时间：数据传送
    * **寻道时间**占比最大
  * **调度方法（寻道算法）：**
    * 先来先服务（FCFS）
    * 最短寻道时间优先（SSTF）
    * 扫描算法（电梯算法）
    * 单向扫描算法

---



